var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Documentation","text":""},{"location":"index.html#overview","title":"Overview","text":"<p>This project is a <code>solution</code> to the business problem of reducing <code>excess</code> products or creating new products from <code>pairing up existing ones</code>. It uses a sample data source that resembles a dataset in the business.</p> <p></p>"},{"location":"index.html#algorithms","title":"Algorithms","text":"<ol> <li>Pairing optimization (PO) maximizes the number of products that can be generated whithout leaving any oprhan pairs.</li> <li>Sequential analysis of pairs that can be generated. This answers the concern of generating pairs in different sizes of the spectrum.</li> </ol>"},{"location":"index.html#usage","title":"Usage","text":"<p>To use the project, you will need to have a sample data file in the same directory as the project code. The sample data file should be xlsx file with the following columns:</p> <p>Example</p> <p>Input data format</p> constraints component resource Brand 1 PANT 3 <pre><code>constraints: product or item features\ncomponent: components that makes up the pair\nresource: numeric / quantities of the products\n</code></pre>"},{"location":"index.html#result","title":"Result \u2705","text":"<p>This will generate a report that shows the number of assortments/kits/bundles/sets that can be generated, as well as the maximum amounts of continous combinations.</p>"},{"location":"index.html#directory-structure","title":"Directory Structure","text":"<pre><code>.\n\u251c\u2500\u2500 docs &lt;- markdown files for mkdocs\n\u2502   \u2514\u2500\u2500 img &lt;- assets\n\u251c\u2500\u2500 notebooks &lt;- jupyter notebooks for exploratory analysis and explanation\n\u2514\u2500\u2500 src - scripts for processing data eg. transformations, dataset merges etc.\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 data &lt;- loading, saving and modelling your data\n\u2502   \u2514\u2500\u2500 features &lt;- algorithms and feature engineering\n\u251c\u2500\u2500 LICENSE &lt;- License\n\u251c\u2500\u2500 mkdocs.yml &lt;- config for mkdocs\n\u251c\u2500\u2500 pyproject.yml &lt;- config project\n\u2514\u2500\u2500 README.md &lt;- README file of the package\n</code></pre> <p>Contributing</p> <p>To contribute create a PR a use conventional commits</p> <pre><code>fix: &lt;description&gt;\nfeat: &lt;description&gt;\ndocs: &lt;description&gt;\nrefactor: &lt;description&gt;\n</code></pre> <p>License</p> <p>The project is licensed under the MIT License.</p> <p>I hope this is helpful! \ud83d\ude04</p>"},{"location":"algorithm.html","title":"Algorithm","text":""},{"location":"algorithm.html#po.features.pairing_optimization.po","title":"<code>po.features.pairing_optimization.po(dataframe, constraints, components, resource)</code>","text":"<p>Pairing Optimization (po) generates pairs (kits, bundles, or sets) of products based on constraints</p> <p>Parameters:</p> Name Type Description Default <code>dataframe</code> <code>DataFrame</code> <p>dataframe with columns/features</p> required <code>constraints</code> <code>list</code> <p>constraint or characteristics that every pair must have in common</p> required <code>components</code> <code>list</code> <p>components that makes up the pair</p> required <code>resource</code> <code>list</code> <p>resource numeric variable to pair</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: dataframe with maximum number of possible pairing that can be generated based on the requirements</p> Source code in <code>src/po/features/pairing_optimization.py</code> <pre><code>def po(dataframe: pd.DataFrame, constraints: list, components: list, resource: list) -&gt; pd.DataFrame:\n    \"\"\"Pairing Optimization (po) generates pairs (kits, bundles, or sets) of products based on constraints\n\n    Args:\n        dataframe (pd.DataFrame): dataframe with columns/features\n        constraints (list): constraint or characteristics that every pair must have in common\n        components (list): components that makes up the pair\n        resource (list): resource numeric variable to pair\n\n    Returns:\n        pd.DataFrame: dataframe with maximum number of possible pairing that can be generated based on the requirements\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    # group data based on the determined constraints and compenents that can be created with the resources\n    all_fields = constraints + components\n\n    df_determine_group = dataframe.groupby(all_fields)[resource].sum().reset_index()\n    # shape dataframe to find pairing items/components for the given constraints\n    df_group_pt = pd.pivot_table(df_determine_group, index=constraints, columns=components, fill_value=0)\n    # determine if pair is possible\n    df_group_pt[\"pairfilter\"] = np.multiply(df_group_pt.iloc[:, 0].values, df_group_pt.iloc[:, 1].values)\n    # find successful pairs\n    df_group_pt_set = df_group_pt.loc[df_group_pt[\"pairfilter\"] != 0].drop(columns=df_group_pt.columns[[2]], axis=1)\n    # reshape dataframe back to initial shape where features are each column to find max number of pairs\n    df_group_pt_set_stack = df_group_pt_set.stack(future_stack=True)\n    # find max amoutn of pairs possible without orphans given the contraints and resource\n    # Min resource assure there are no orphans\n    df_group_min = df_group_pt_set_stack.groupby(constraints)[df_group_pt_set_stack.columns[0]].min().reset_index()\n\n    return df_group_min\n</code></pre>"},{"location":"algorithm.html#example-of-pairing-optimization-po","title":"Example of pairing optimization (po)","text":"<p>Note</p> <p>Group observations based on the determined constraints and compenents that can be created with the resources</p> Brand ColorName Gender Size Type On Hand Brand 9 color 95 WOMEN XL TOP 0 Brand 9 color 95 WOMEN XS PANT 10 <p>Note</p> <p>Shape dataframe to find pairing of components for the given constraints</p> Brand ColorName Gender Size PANT TOP Brand 9 color 95 WOMEN M 14 0 Brand 9 color 95 WOMEN S 0 0 <p>Note</p> <p>determine if pair is possible</p> Brand ColorName Gender Size PANT TOP pairfilter Brand 9 color 95 WOMEN M 14 0 0 Brand 9 color 95 WOMEN S 0 0 0 <p>Note</p> <p>Find successful pairs</p> Brand ColorName Gender Size PANT TOP Brand 9 color 5953 WOMEN M 263 160 Brand 9 color 5953 WOMEN S 218 106 <p>Note</p> <p>Reshape dataframe back to initial shape where features are each column to find max number of pairs</p> Brand ColorName Gender Size Type On Hand Brand 1 color 1 WOMEN L PANT 2 Brand 1 color 1 WOMEN L TOP 103 <p>Success</p> <p>Maximum amount of possible pairs</p> Brand ColorName Gender Size On Hand Brand 1 color 1 WOMEN L 2 Brand 1 color 1 WOMEN XL 1"},{"location":"algorithm.html#po.features.pairing_optimization.max_streak","title":"<code>po.features.pairing_optimization.max_streak(dataframe, range_start, range_end)</code>","text":"<p>Calculate streaks of positive values in a DataFrame also referred to as a \"streak counting algorithm\" or simply a \"streak counter.</p> <p>Parameters:</p> Name Type Description Default <code>dataframe</code> <code>DataFrame</code> <p>wide format where the columnts to be counter             are columns and characteristics as the beginning</p> required <code>range_start</code> <code>int</code> <p>start of values index</p> required <code>range_end</code> <code>int</code> <p>end of values index</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: dataframe with a new column showing the longest continous streak</p> Source code in <code>src/po/features/pairing_optimization.py</code> <pre><code>def max_streak(dataframe: pd.DataFrame, range_start: int, range_end: int) -&gt; pd.DataFrame:\n    \"\"\"Calculate streaks of positive values in a DataFrame also\n    referred to as a \"streak counting algorithm\" or simply a \"streak counter.\n\n    Args:\n        dataframe (pd.DataFrame): wide format where the columnts to be counter \\\n            are columns and characteristics as the beginning\n        range_start (int): start of values index\n        range_end (int): end of values index\n\n    Returns:\n        pd.DataFrame: dataframe with a new column showing the longest continous streak\n    \"\"\"\n\n    # find all products with a possible set\n    # https://stackoverflow.com/questions/45964740/python-pandas-cumsum-with-reset-everytime-there-is-a-0\n    # https://stackoverflow.com/questions/51278155/python-dataframe-counter-on-a-column\n    # https://stackoverflow.com/questions/41420822/conditional-cumulative-sum-in-python-pandas\n    # https://stackoverflow.com/questions/54737294/how-to-reset-cumulative-sum-every-time-there-is-a-nan-in-a-pandas-dataframe\n\n    # This line checks if the values in the DataFrame are positive\n    positive = dataframe.iloc[:, range_start:range_end] &gt; 0\n\n    # This line calculates the cumulative sum along the along columns\n    # for the positive values, effectively creating a counter for streaks of positive values.\n    counter = positive.cumsum(axis=1)\n\n    # This line fills the NaN values in 'counter' with the last valid observation along columns,\n    # effectively propagating the last valid value forward to fill the NaNs.\n    trailing_counter = counter.where(~positive, axis=0).ffill(axis=1).fillna(0).astype(int)\n\n    # This line calculates the difference between the cumulative sum 'counter' and the trailing counts after a restart,\n    # which effectively gives the length of each streak of positive values.\n    d = counter - trailing_counter\n\n    # This line assigns the maximum streak length along columns to a new column 'NumOfContinous' in the DataFrame.\n    dataframe[\"maxcontinous\"] = d.max(axis=1)\n\n    return dataframe\n</code></pre>"},{"location":"data.html","title":"Data","text":""},{"location":"data.html#po.data.readingdata","title":"<code>po.data.readingdata</code>","text":""},{"location":"data.html#po.data.readingdata.file_path_finder","title":"<code>file_path_finder(file_name)</code>","text":"<p>generates path from folder name called data and file name.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>file name</p> required <p>Returns:</p> Name Type Description <code>df_dir</code> <code>str</code> <p>directory of file</p> Source code in <code>src/po/data/readingdata.py</code> <pre><code>def file_path_finder(file_name: str) -&gt; str:\n    \"\"\"generates path from folder name called data and file name.\n\n    Args:\n        file_name (str): file name\n\n    Returns:\n        df_dir (str): directory of file\n    \"\"\"\n    import glob\n    import os\n\n    main_dir = os.path.dirname(os.getcwd())\n    rawdata_dir = os.path.join(main_dir, \"data\", file_name)\n    df_dir = glob.glob(rawdata_dir)[0]\n    return df_dir\n</code></pre>"},{"location":"tool/po_tool.html","title":"Po tool","text":""},{"location":"tool/po_tool.html#pairing-optimization-tool","title":"Pairing Optimization Tool \ud83d\udd27","text":""}]}